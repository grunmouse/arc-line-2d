## Симплекс-метод

Обозначим 
- $m$ - количество зависимых переменных;
- $n$ - количество независимых переменных;
- $X_k: Matrix(n, 1)$ - вектор независимых переменных для шага $k$;
- $Y_k: Matrix(m, 1)$ - вектор зависимых переменных для шага $k$;
- $\hat X_k = \begin{pmatrix} X_k^T & 1 \end{pmatrix}^T$ - расширенный вектор $X_k$;
- $A_k: Matrix(m, n)$ - матрица коэффициентов условий-уравнений над $X_k,\,Y_k$;
- $b_k: Matrix(m, 1)$ - вектор свободных членов условий-уравнений над $X_k,\,Y_k$;
- $\hat A_k = \begin{pmatrix}A_k & b_k\end{pmatrix}$ - матрица оператора, отображающего $\hat X_k$ на $Y_k$;
- $c_k: Matrix(m, 1)$ - вектор коэффициентов целевой функции для шага $k$;
- $d_k$ - свободный член целевой функции для шага $k$;
- $\hat c_k = \begin{pmatrix}c_k^T & d_k\end{pmatrix}^T$ - вектор, отображающий $\hat X_k$ в значение целевой функции;
- $N_{k,l}: Matrix(m, n+1)$ - матрица оператора, отображающего $\hat X_k$ на $Y_l$;
- $B_{k,l}: Matrix(n+1, n+1)$ - матрица оператора, отображающего $\hat X_k$ на $\hat X_l$.

Условия-уравнения:
$$Y_k = \hat A_k \hat X_k.$$

Условия-неравенства:
$$X_k[i] \ge 0,\, i \in [1, n];$$
$$Y_k[i] \ge 0,\, i \in [1, m].$$

Целевая функция:
$$F = \hat c_k^T \hat X_k.$$

Соотношения:
$$Y_l = N_{k,l} \hat X_k;$$
$$\hat X_l = B_{k,l} \hat X_k;$$
$$\hat A_l = N_{k,l} B_{k,l}^{-1};$$
$$\hat c_l = (B_{k,l}^{-1})^T \hat c_k.$$

На каждом шаге нужно оценить возможность дальнейшей оптимизации, при наличии таковой, выбрать из $X_k$ входную переменную, а из $Y_k$ - выходную переменную, после чего составить $X_{k+1}$ и $Y_{k+1}$ в которых входная и выходная переменные обменяны местами по сравнению с $X_k$ и $Y_k$.

Для выбора входной переменной анализируем вектор $c_k$.
Если мы максимизируем целевую функцию, то ищем наибольший по модулю положительный член вектора.
Если минимизируем - то наибольший по модулю отрицательный.
Если нам подходят несколько членов - выбираем первый из них или применяем дополнительный алгоритм выбора.
Если подходящих членов не существует - значит дальнейшая оптимизация невозможна.

Обозначим:
- $x_k : Matrix(n, 1)$ - вектор, в котором в позиции выбранного члена $c_k$ стоит 1, а в остальных 0.
- $S_k : Matrix(m, 1)$ - вектор значений, которые примет выбранная входная переменная при выборе выходной.

Составим систему уравнений:
$$diag(A_k x_k) S_k + b_k = O_{m, 1};$$
$$diag(A_k x_k) S_k = -b_k;$$
$$S_k = -(diag(A_k x_k))^{-1} b_k.$$

$(diag(A_k x_k))^{-1}$ нельзя вычислить стандартным способом, поэтому нужно использовать формулу для диагональных матриц, приняв $0^{-1} = \infty$.

Теперь анализируем $S_k$.
Ищем наименьшее положительное значение. Если их несколько, выбираем первое из них или применяем дополнительный алгоритм выбора.

Обозначим:
- $y_k : Matrix(m, 1)$ - вектор, в котором в позиции выбранного члена $S_k$ стоит 1, а в остальных 0.

Новые кортежи векторов из старых можно получить перестановкой:
$$
\begin{pmatrix}
	Y_l \\
	\hat X_l
\end{pmatrix}
= P_{k,l}
\begin{pmatrix}
	Y_k \\
	\hat X_k
\end{pmatrix}
$$
где
- $P_{k,l} : Matrix(m+n+1, m+n+1)$ - представляет собой матрицу перестановки,
- $X_l$, $Y_l$, $X_k$, $Y_k$ - понимаются как кортежи имён переменных, а не массивы значений

Тогда
$$
\begin{pmatrix}
	N_{k,l} \\
	B_{k,l}
\end{pmatrix}
= P_{k,l}
\begin{pmatrix}
	\hat A_k \\
	E_{n+1}
\end{pmatrix}
$$

Матрицу $P_{k,l}$ можно рассматривать поблочно:
$$P_{k,l} = \begin{pmatrix} P_{Y,k,l} \\ P_{X,k,l} \end{pmatrix}$$
Тогда:
$$Y_l = P_{Y,k,l} \begin{pmatrix} Y_k \\ \hat X_k \end{pmatrix}$$
$$\hat X_l = P_{X,k,l} \begin{pmatrix} Y_k \\ \hat X_k \end{pmatrix}$$

$$
N_{k,l} = P_{Y,k,l}
\begin{pmatrix}
	\hat A_k \\
	E_{n+1}
\end{pmatrix}
$$
$$
B_{k,l}
= P_{X,k,l}
\begin{pmatrix}
	\hat A_k \\
	E_{n+1}
\end{pmatrix}
$$


$P_{k,k} = E_{n+m+1}$ - тождественное отображение.
$$P_{k,l} 
= \begin{pmatrix} P_{Y,k,k} \\ P_{X,k,k} \end{pmatrix}
= \begin{pmatrix} 
	E_{m} & O_{m,n+1} \\ 
	O_{n+1,m} & E_{n+1}
\end{pmatrix}
$$

При переходе от шага $k$ к шагу $k+1$ мы заменяем только одну независимую переменную. Поэтому целесообразно чтобы остальные независимые переменные не меняли своих позиций.

Расширим:
- $\hat x_k = \begin{pmatrix}x_k^T & 0 \end{pmatrix}^T$
- $\bar x_k = \begin{pmatrix}O_{1, m} & \hat x_k^T\end{pmatrix}^T$
- $\bar y_k = \begin{pmatrix}y_k^T & O_{1, n+1}\end{pmatrix}^T$

$$(\bar y_k - \bar x_k) = \begin{pmatrix}y_k \\ -\hat x_k\end{pmatrix}.$$

$$P_{X,k,k+1} = P_{X,k,k} + \hat x_k (\bar y_k - \bar x_k)^T.$$

Если аналогично поступить с зависимыми переменными, получим:

$$P_{Y, k, k+1} = P_{Y,k,k} + y_k (\bar x_k - \bar y_k)^T.$$

$$P_{k, k+1} = P_{k,k} + \bar x_k (\bar y_k - \bar x_k)^T + \bar y_k (\bar x_k - \bar y_k)^T;$$
$$P_{k, k+1} = P_{k,k} + \bar x_k (\bar y_k - \bar x_k)^T - \bar y_k (\bar y_k - \bar x_k)^T;$$
$$P_{k, k+1} = P_{k,k} + (\bar x_k - \bar y_k) (\bar y_k - \bar x_k)^T;$$
$$P_{k, k+1} = P_{k,k} - (\bar y_k - \bar x_k) (\bar y_k - \bar x_k)^T.$$

Введём оператор $\#$.
Оператор $\#$ от матрицы перестановки и возвращает вектор-столбец, содержащий номера позиций единицы в каждой строке матрицы. Оператор $\#$ от базисного орта возвращает число, равное номеру позиции единицы в векторе. Тогда:
- $\#x_k$ - номер входной переменной в векторе $X_k$;
- $\#y_k$ - номер выходной переменной в векторе $Y_k$;
- $\#\hat x_k = \#x_k$;
- $\#\bar x_k = \#x_k + m$;
- $\#\bar y_k = \#y_k$.

$$P_{k, k+1} = permut(\#x_k + m,\, \#y_k).$$

#### Алгоритм
Входные данные: $m,\, n,\, X_0,\, Y_0,\,  A_0,\, b_0,\, c_0,\, d_0$.

На каждом шаге $k$:
- анализируем $c_k$ и выбираем $x_k$ или заканчиваем работу;
- из $A_k,\, b_k$ и $x_k$ рассчитываем $S_k$;
- анализируем $S_k$ и выбираем $y_k$;
- из $x_k,\, y_k$ рассчитываем $P_{k,k+1} = permut(\#x_k + m,\, \#y_k)$;
- перестановкой $P_{k, k+1}$ из $Y_k,\, \hat X_k$ получаем $Y_{k+1},\, \hat X_{k+1}$, а из $\hat A_k$ рассчитываем $N_{k,{k+1}},\, B_{k,{k+1}}$;
- по формулам рассчитываем $\hat A_{k+1} = N_{k,{k+1}} B_{k,{k+1}}^{-1}$, $\hat c_{k+1} = (B_{k,{k+1}}^{-1})^T \hat c_k$;
- разделяем $\hat A_{k+1}$ на $A_{k+1},\, b_{k+1}$, а $\hat c_{k+1}$ на $c_{k+1},\, d_{k+1}$.

### Анализ свойств матриц
$$\begin{cases}
	x_k[i] = 1, & i = \#x_k, \\
	x_k[i] = 0, & i \ne \#x_k;
\end{cases}$$

$$(A_k x_k)[i] = A_k[i,\#x_k];$$

$$\begin{cases}
	diag(A_k x_k)[i,j] = A_k[i,\#x_k], & i = j, \\
	diag(A_k x_k)[i,j] = 0, & i \ne j;
\end{cases}$$

$$\begin{cases}
	(diag(A_k x_k))^{-1}[i,j] = \frac{1}{A_k[i,\#x_k]}, & i = j, \\
	(diag(A_k x_k))^{-1}[i,j] = 0, & i \ne j;
\end{cases}$$

$$S_k[i] = -\frac{b_k[i]}{A_k[i,\#x_k]};$$

$$\begin{cases}
	P_{k,k+1}[i,j] = 1, & i = \#x_k + m \wedge j = \#y_k, \\
	P_{k,k+1}[i,j] = 1, & i = \#y_k \wedge j = \#x_k + m, \\
	P_{k,k+1}[i,j] = 1, & i = j \wedge i \ne \#x_k + m \wedge i \ne \#y_k, \\
	P_{k,k+1}[i,j] = 0, & i = j \wedge (i = \#x_k + m \vee i = \#y_k), \\
	P_{k,k+1}[i,j] = 0, & i \ne \#x_k + m \wedge i \ne \#y_k \wedge i \ne j;
\end{cases}$$

$$P_{X,k,l}[i,j] = P_{k,l}[i+m,j];$$
$$P_{Y,k,l}[i,j] = P_{k,l}[i,j];$$

$$\begin{cases}
	N_{k,k+1}[i,j] = \hat A_k[i,j], & i \ne \#y_k, \\
	N_{k,k+1}[i,j] = 1, & i = \#y_k \wedge j = \#x_k, \\
	N_{k,k+1}[i,j] = 0, & i = \#y_k \wedge j \ne \#x_k;
\end{cases}
$$
$N_{k,k+1}$ отличается от $\hat A_k$ только строкой $\#y_k$, которая заменена на $\#x_k$ строку единичной матрицы.

$$\begin{cases}
	B_{k,k+1}[i,j] = 1, & i \ne \#x_k \wedge i=j,\\
	B_{k,k+1}[i,j] = 0, & i \ne \#x_k \wedge i \ne j,\\
	B_{k,k+1}[i,j] = \hat A_k[\#y_k,j] & i = \#x_k;
\end{cases}$$

$B_{k,k+1}$ отличается от единичной матрицы только строкой $\#x_k$, которая заменена на $\#y_k$ строку матрицы $\hat A_k$.

$$\begin{cases}
	\hat A_k[i,j] = A_k[i,j], & j \le n,\\
	\hat A_k[i,j] = b_k[i], & j = n+1;
\end{cases}$$